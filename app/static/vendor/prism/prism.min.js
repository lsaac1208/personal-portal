/*!
 * Prism.js (minimal version)
 * Licensed under MIT
 */

/* 全局Prism对象 */
var Prism = (function(_self){
  var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  var uniqueId = 0;

  _self.manual = false;
  _self.disableWorkerMessageHandler = false;

  _self.util = {
    encode: function encode(tokens) {
      if (tokens instanceof Token) {
        return new Token(tokens.type, encode(tokens.content), tokens.alias);
      } else if (Array.isArray(tokens)) {
        return tokens.map(encode);
      } else {
        return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
      }
    },
    
    type: function (o) {
      return Object.prototype.toString.call(o).slice(8, -1);
    },
    
    objId: function (obj) {
      if (!obj['__id']) {
        Object.defineProperty(obj, '__id', { value: ++uniqueId });
      }
      return obj['__id'];
    },
    
    clone: function deepClone(o, visited) {
      visited = visited || new Map();
      var clone, id;
      var type = _self.util.type(o);
      
      switch (type) {
        case 'Object':
          id = _self.util.objId(o);
          if (visited.has(id)) {
            return visited.get(id);
          }
          clone = {};
          visited.set(id, clone);
          
          for (var key in o) {
            if (o.hasOwnProperty(key)) {
              clone[key] = deepClone(o[key], visited);
            }
          }
          
          return clone;
          
        case 'Array':
          id = _self.util.objId(o);
          if (visited.has(id)) {
            return visited.get(id);
          }
          clone = [];
          visited.set(id, clone);
          
          o.forEach(function (v, i) {
            clone[i] = deepClone(v, visited);
          });
          
          return clone;
          
        default:
          return o;
      }
    },
    
    getLanguage: function(element) {
      while (element && !lang.test(element.className)) {
        element = element.parentElement;
      }
      if (element) {
        return (element.className.match(lang) || [,'none'])[1].toLowerCase();
      }
      return 'none';
    }
  };

  _self.languages = {
    extend: function (id, redef) {
      var lang = _self.util.clone(_self.languages[id]);
      for (var key in redef) {
        lang[key] = redef[key];
      }
      return lang;
    },
    
    insertBefore: function (inside, before, insert, root) {
      root = root || _self.languages;
      var grammar = root[inside];
      var ret = {};
      
      for (var token in grammar) {
        if (grammar.hasOwnProperty(token)) {
          if (token == before) {
            for (var newToken in insert) {
              if (insert.hasOwnProperty(newToken)) {
                ret[newToken] = insert[newToken];
              }
            }
          }
          ret[token] = grammar[token];
        }
      }
      
      var old = root[inside];
      root[inside] = ret;
      _self.languages.DFS(_self.languages, function(key, value) {
        if (value === old && key != inside) {
          this[key] = ret;
        }
      });
      
      return ret;
    },
    
    DFS: function DFS(o, callback, type, visited) {
      visited = visited || new Map();
      var objId = _self.util.objId;
      
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          callback.call(o, i, o[i], type || i);
          
          var property = o[i],
              propertyType = _self.util.type(property);
          
          if (propertyType === 'Object' && !visited.has(objId(property))) {
            visited.set(objId(property), true);
            DFS(property, callback, null, visited);
          }
          else if (propertyType === 'Array' && !visited.has(objId(property))) {
            visited.set(objId(property), true);
            DFS(property, callback, i, visited);
          }
        }
      }
    }
  };

  var Token = _self.Token = function Token(type, content, alias, matchedStr, greedy) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = (matchedStr || '').length|0;
    this.greedy = !!greedy;
  };

  Token.stringify = function stringify(o, language) {
    if (typeof o == 'string') {
      return o;
    }
    if (Array.isArray(o)) {
      var s = '';
      o.forEach(function (e) {
        s += stringify(e, language);
      });
      return s;
    }
    
    var env = {
      type: o.type,
      content: stringify(o.content, language),
      tag: 'span',
      classes: ['token', o.type],
      attributes: {},
      language: language
    };
    
    var aliases = o.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    
    _self.hooks.run('wrap', env);
    
    var attributes = '';
    for (var name in env.attributes) {
      attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    }
    
    return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
  };

  _self.tokenize = function(text, grammar) {
    var rest = text;
    var tokenList = [];
    var token, match;
    
    if (!grammar) {
      return [text];
    }
    
    for (var key in grammar) {
      if (!grammar.hasOwnProperty(key) || !grammar[key]) {
        continue;
      }
      
      var patterns = grammar[key];
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      
      for (var j = 0; j < patterns.length; ++j) {
        if (tokenList.length >= 100) break;
        
        var pattern = patterns[j];
        var inside = pattern.inside;
        var lookbehind = !!pattern.lookbehind;
        var greedy = !!pattern.greedy;
        var lookbehindLength = 0;
        var alias = pattern.alias;
        
        if (greedy && !pattern.pattern.global) {
          var flags = pattern.pattern.toString().match(/[imsuy]*$/)[0];
          pattern.pattern = RegExp(pattern.pattern.source, flags + 'g');
        }
        
        pattern = pattern.pattern || pattern;
        
        while (match = pattern.exec(rest)) {
          var from = match.index;
          var matchStr = match[0];
          var before = rest.slice(0, from);
          var after = rest.slice(from + matchStr.length);
          
          if (lookbehind) {
            lookbehindLength = match[1] ? match[1].length : 0;
          }
          
          var wrapped = new Token(key, inside ? _self.tokenize(matchStr.slice(lookbehindLength), inside) : matchStr.slice(lookbehindLength), alias, matchStr.slice(lookbehindLength), greedy);
          
          if (before) tokenList.push(before);
          tokenList.push(wrapped);
          if (after) rest = after;
          else break;
          
          if (!greedy) break;
        }
      }
    }
    
    return tokenList.length ? tokenList : [text];
  };

  _self.highlight = function (text, grammar, language) {
    var env = {
      code: text,
      grammar: grammar,
      language: language
    };
    _self.hooks.run('before-tokenize', env);
    env.tokens = _self.tokenize(env.code, env.grammar);
    _self.hooks.run('after-tokenize', env);
    return Token.stringify(_self.util.encode(env.tokens), env.language);
  };

  _self.highlightElement = function(element, async, callback) {
    var language = _self.util.getLanguage(element);
    var grammar = _self.languages[language];
    
    element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
    
    var parent = element.parentElement;
    if (parent && parent.nodeName.toLowerCase() === 'pre') {
      parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
    }
    
    var code = element.textContent;
    
    var env = {
      element: element,
      language: language,
      grammar: grammar,
      code: code
    };
    
    function insertHighlightedCode(highlightedCode) {
      env.highlightedCode = highlightedCode;
      _self.hooks.run('before-insert', env);
      env.element.innerHTML = env.highlightedCode;
      _self.hooks.run('after-highlight', env);
      _self.hooks.run('complete', env);
      callback && callback.call(env.element);
    }
    
    _self.hooks.run('before-sanity-check', env);
    
    if (!env.code) {
      _self.hooks.run('complete', env);
      callback && callback.call(env.element);
      return;
    }
    
    _self.hooks.run('before-highlight', env);
    
    if (!env.grammar) {
      insertHighlightedCode(_self.util.encode(env.code));
      return;
    }
    
    if (async && _self.Worker) {
      var worker = new _self.Worker(_self.filename);
      
      worker.onmessage = function(evt) {
        insertHighlightedCode(evt.data);
      };
      
      worker.postMessage(JSON.stringify({
        language: env.language,
        code: env.code,
        immediateClose: true
      }));
    }
    else {
      insertHighlightedCode(_self.highlight(env.code, env.grammar, env.language));
    }
  };

  _self.highlightAll = function(async, callback) {
    _self.highlightAllUnder(document, async, callback);
  };

  _self.highlightAllUnder = function(container, async, callback) {
    var env = {
      callback: callback,
      container: container,
      selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    };
    
    _self.hooks.run('before-highlightall', env);
    
    env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
    
    _self.hooks.run('before-all-elements-highlight', env);
    
    for (var i = 0, element; element = env.elements[i++];) {
      _self.highlightElement(element, async === true, env.callback);
    }
  };

  _self.hooks = {
    all: {},
    add: function (name, callback) {
      var hooks = _self.hooks.all;
      hooks[name] = hooks[name] || [];
      hooks[name].push(callback);
    },
    run: function (name, env) {
      var callbacks = _self.hooks.all[name];
      if (!callbacks || !callbacks.length) {
        return;
      }
      for (var i = 0, callback; callback = callbacks[i++];) {
        callback(env);
      }
    }
  };

  // 基础语言定义
  _self.languages.markup = {
    'comment': /<!--[\s\S]*?-->/,
    'prolog': /<\?[\s\S]+?\?>/,
    'doctype': {
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        'internal-subset': {
          pattern: /(\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
        },
        'string': {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        'punctuation': /^<!|>$|[[\]]/,
        'doctype-tag': /^DOCTYPE/,
        'name': /[^\s<>'"]+/
      }
    },
    'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
    'tag': {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        'tag': {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            'punctuation': /^<\/?/,
            'namespace': /^[^\s>\/:]+:/
          }
        },
        'attr-value': {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            'punctuation': [
              {
                pattern: /^=/,
                alias: 'attr-equals'
              },
              /"|'/
            ]
          }
        },
        'punctuation': /\/?>/,
        'attr-name': {
          pattern: /[^\s>\/]+/,
          inside: {
            'namespace': /^[^\s>\/:]+:/
          }
        }
      }
    },
    'entity': [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: 'named-entity'
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };

  _self.languages.html = _self.languages.markup;
  _self.languages.mathml = _self.languages.markup;
  _self.languages.svg = _self.languages.markup;

  _self.languages.xml = _self.languages.extend('markup', {});
  _self.languages.ssml = _self.languages.xml;
  _self.languages.atom = _self.languages.xml;
  _self.languages.rss = _self.languages.xml;

  // CSS
  _self.languages.css = {
    'comment': /\/\*[\s\S]*?\*\//,
    'atrule': {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        'rule': /^@[\w-]+/,
        'selector-function-argument': {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: 'selector'
        },
        'keyword': {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
      }
    },
    'url': {
      pattern: RegExp('\\burl\\((?:' + ["'(?:[^\\\\'\r\n]|\\\\.)*'", '"(?:[^\\\\"\r\n]|\\\\.)*"', '[^\\\\)\\r\\n]*'].join('|') + ')\\)', 'i'),
      greedy: true,
      inside: {
        'function': /^url/i,
        'punctuation': /^\(|\)$/,
        'string': {
          pattern: RegExp('^(?:' + ["'(?:[^\\\\'\r\n]|\\\\.)*'", '"(?:[^\\\\"\r\n]|\\\\.)*"'].join('|') + ')$'),
          alias: 'url'
        }
      }
    },
    'selector': RegExp('[^{}\\s](?:[^{};"\']|"(?:[^\\\\"]|\\\\.)*"|\'(?:[^\\\\\']|\\\\.)*\')*(?=\\s*\\{)'),
    'string': {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    'property': {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?:(?:-)?\w+(?:-\w+)*)\s*:/,
      lookbehind: true,
      inside: {
        'punctuation': /:/
      }
    },
    'important': /!important\b/i,
    'function': {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    'punctuation': /[(){};:,]/
  };

  // JavaScript
  _self.languages.javascript = _self.languages.extend('clike', {
    'class-name': [
      _self.languages.clike['class-name'],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor|new))/,
        lookbehind: true
      }
    ],
    'keyword': [
      {
        pattern: /((?:^|})\s*)(?:catch|finally)\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    'function': /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });

  _self.languages.js = _self.languages.javascript;

  // 基础 C-like 语言
  _self.languages.clike = {
    'comment': [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    'string': {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    'class-name': {
      pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        'punctuation': /[.\\]/
      }
    },
    'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    'boolean': /\b(?:true|false)\b/,
    'function': /\w+(?=\()/,
    'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    'punctuation': /[{}[\];(),.:]/
  };

  // Python
  _self.languages.python = {
    'comment': {
      pattern: /(^|[^\\])#.*/,
      lookbehind: true
    },
    'string-interpolation': {
      pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: true,
      inside: {
        'interpolation': {
          pattern: /((?:^|[^{])(?:{{)*){(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
          lookbehind: true,
          inside: {
            'format-spec': {
              pattern: /(:)[^}]+(?=}$)/,
              lookbehind: true
            },
            'conversion-option': {
              pattern: /![sra](?=[:}]$)/,
              alias: 'punctuation'
            },
            rest: null
          }
        },
        'string': /[\s\S]+/
      }
    },
    'triple-quoted-string': {
      pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]*?\1/i,
      greedy: true,
      alias: 'string'
    },
    'string': {
      pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: true
    },
    'function': {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: true
    },
    'class-name': {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: true
    },
    'decorator': {
      pattern: /(^\s*)@\w+(?:\.\w+)*/im,
      lookbehind: true,
      alias: ['annotation', 'punctuation'],
      inside: {
        'punctuation': /\./
      }
    },
    'keyword': /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    'builtin': /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    'boolean': /\b(?:True|False|None)\b/,
    'number': /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
    'operator': /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    'punctuation': /[{}[\];(),.:]/
  };

  // 自动高亮
  var script = document.currentScript || (function() {
    var scripts = document.getElementsByTagName('script');
    return scripts[scripts.length - 1];
  })();

  if (script && !script.hasAttribute('data-manual')) {
    if (document.readyState !== 'loading') {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(_self.highlightAll);
      } else {
        window.setTimeout(_self.highlightAll, 16);
      }
    } else {
      document.addEventListener('DOMContentLoaded', _self.highlightAll);
    }
  }

  return _self;

})(typeof window !== 'undefined' ? window : {});

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Prism;
}

// 如果在浏览器环境，自动执行语法高亮
if (typeof window !== 'undefined') {
  window.Prism = Prism;
}